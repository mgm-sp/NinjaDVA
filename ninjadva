#!/usr/bin/env ruby

require "yaml"
require 'io/console'

# usage
usage = <<-END
	usage:
	#{$0} up -- start NinjaDVA components
	#{$0} halt -- stop components
	#{$0} status -- show running components
	#{$0} change -- stop or start additional components
	#{$0} harthalt -- hart kill all VirtualBoxes system wide
END


# print usage if no no arguments
if ARGV.size == 0
	puts usage
	exit
end
# ---- define functions ------

def start_vagrant(pathToVagrantfile)
	return system("cd #{pathToVagrantfile}; vagrant up")
end

def stop_vagrant(pathToVagrantfile)
	return system("cd #{pathToVagrantfile}; vagrant halt")
end

def poweroff_all_virtualboxes()
	return system("vboxmanage list runningvms | sed -r 's/.*\\{(.*)\\}/\\1/' | xargs -L1 -I {} VBoxManage controlvm {} poweroff")
end

def get_running_vms()
	runningVmsRequest = `vboxmanage list runningvms`.split(/\n+/)
	runningVms = []
	runningVmsRequest.each{|e|
		runningVagrantVm = e.split("\"")[1].scan(/^(.*)_(.*)_[0-9]+_[0-9]+$/).flatten[0]
		# avoid adding vms not named in vagrant style
		if runningVagrantVm
			runningVms.push(runningVagrantVm)
		end
	}
	return runningVms
end

def get_gateway_position(arrayOfVmPaths)
	gatewayPos = arrayOfVmPaths.index{|s| s== "gateway_vm"}
	raise "No gateway VM" unless gatewayPos
	return gatewayPos
end

# --- begin of script ------

# try to load config file
configFile = ".ninjadvarc.yaml"
vmSettingsConfig = {}
if File.exists?(configFile)
	vmSettingsConfig = YAML::load_file(configFile)
end

# search for subdirectories having Vagrantfile
vmsFound = Dir.glob("**/Vagrantfile").collect{|f| File.dirname(f)}

#handle no vms found
if vmsFound.length == 0
	puts "No VMs found :/ ... exit"
	exit
end

# handle no gateway vm found and exclude gateway from decision
begin
	gatewayPos = get_gateway_position(vmsFound)
rescue
	puts "No gateway VM found :/ ... exit"
	exit
end
gatewayPath = vmsFound.delete(vmsFound[gatewayPos])


# merge vms found with vms in config
vmStartDefinition = {}
vmsFound.each{|e| vmStartDefinition[e] = false}
# get subset of vms that can be found currently
vmSettingsConfigExistSubset = vmSettingsConfig.select{|k,v| (vmStartDefinition.keys & vmSettingsConfig.keys).include?(k)}
vmStartDefinition.merge!(vmSettingsConfigExistSubset)
vmsCount = vmStartDefinition.keys.count
# get vm directories cleaned, only the last sub-directory
vmFoundCleaned = []
vmStartDefinition.keys.each{|e|
	vmFoundCleaned.push(File.basename(e))
}


case ARGV.first # process subcommands
when "up" # {{{

	puts "VMs with a [X] will be started:"

	loop do
		# print current vm config
		vmStartDefinition.each_with_index {|(k,v),i|
			start = v ? "X" : " "
			puts "[%s] %d  %s" % [start, i+1, k]
		}

		puts "Options: toggle VM start (1-%d), start chosen VMs (S), quit (q)" % [vmsCount]
		print "Decision [Sq1-%d]: " % [vmsCount]
		# get input
		decision = STDIN.gets.chomp

		puts "----------------------------"
		puts

		decisionAsNumber = decision.to_i
		if decision.downcase == "s" or decision == ""
			puts "....STARTING ..... *roedelroedel*....*klimper*...*piep*..."
			puts
			break
		elsif decision.downcase == "q"
			# quit script
			puts "...quit............................."
			exit
		elsif decisionAsNumber.between?(1,vmsCount)
			vmStartDefinition[vmStartDefinition.keys[decisionAsNumber-1]] = !vmStartDefinition[vmStartDefinition.keys[decisionAsNumber-1]]
		else
			puts "(!!!) WRONG INPUT [%s] :/" % [decision]
			puts
		end
	end

	# save new config
	File.open(configFile,"w") do |f|
		f.write(vmSettingsConfig.merge!(vmStartDefinition).to_yaml)
	end

	# start gateway
	puts "starting gateway ...."
	if not start_vagrant(gatewayPath)
		stop_vagrant(gatewayPath)
		puts "Failed to start gateway...exit"
		exit
	end

	# start other VMs
	vmStartDefinition.each{|k,v|
		if v
			puts "starting #{k} ...."
			if not start_vagrant(k)
				stop_vagrant(k)
				puts "Failed to start #{k}...exit"
				exit
			end
		end
	}
# }}}
when "halt"# {{{
	# get running vagrant vms matching subfolders we can find
	vmRunning = get_running_vms()
	vmRunningMatched = vmRunning & vmFoundCleaned

	# stop other VMs
	vmRunningMatched.each{|k|
		puts "stopping #{k} ..."
		if not stop_vagrant(k)
			puts "Failed to stop #{k}...exit"
			exit
		end
	}
	puts "stop gateway..."
	# stop gateway
	if not stop_vagrant(gatewayPath)
		puts "Failed to stop gateway...exit"
		exit
	end
# }}}
when "harthalt"# {{{
	poweroff_all_virtualboxes()
# }}}
when "status"# {{{
	# get running vagrant vms matching subfolders we can find
	vmRunning = get_running_vms()
	vmRunningMatched = vmRunning & vmFoundCleaned

	begin
		gatewayPos = get_gateway_position(vmRunning)
	rescue
		puts "Gateway is not running."
		puts "Run #{$0} up to start NinjaDVA."
		exit
	end

	# print current vm config
	puts "Running VMs are marked with [X]:"
	vmStartDefinition.each {|k,v|
		running = vmRunningMatched.include?(File.basename(k))? "X" : " "
		puts "[%s] %s" % [running, k]
	}
# }}}
when "change"# {{{
	 # get running vagrant vms matching subfolders we can find
	 vmRunning = get_running_vms()
	 vmRunningMatched = vmRunning & vmFoundCleaned

	 begin
		 gatewayPos = get_gateway_position(vmRunning)
	 rescue
		 puts "Gateway is not running."
		 puts "Run #{$0} up to start NinjaDVA."
		 exit
	 end
	puts "Mark mark or unmark components with [X] to start or stop them:"
	vmChangeDefinition = vmStartDefinition.clone
	# update run status
	vmChangeDefinition.each{|k,v|
		vmChangeDefinition[k]=vmRunningMatched.include?(File.basename(k))
	}
	# safe current state
	vmStateBefore = vmChangeDefinition.clone

	loop do
		# print current vm config
		vmChangeDefinition.each_with_index {|(k,v),i|
			start = v ? "X" : " "
			puts "[%s] %d  %s" % [start, i+1, k]
		}

		puts "Options: toggle VM start (1-%d), run change (C), quit (q)" % [vmsCount]
		print "Decision [Cq1-%d]: " % [vmsCount]
		# get input
		decision = STDIN.gets.chomp

		puts "----------------------------"
		puts

		decisionAsNumber = decision.to_i
		if decision.downcase == "c" or decision == ""
			puts "....CHANGING ..... *roedelroedel*....*klimper*...*piep*..."
			puts
			break
		elsif decision.downcase == "q"
			# quit script
			puts "...quit............................."
			exit
		elsif decisionAsNumber.between?(1,vmsCount)
			vmChangeDefinition[vmChangeDefinition.keys[decisionAsNumber-1]] = !vmChangeDefinition[vmChangeDefinition.keys[decisionAsNumber-1]]
			puts
		else
			puts "(!!!) WRONG INPUT [%s] :/" % [decision]
			puts
		end
	end

	# get list of VMs to stop
	vmsToHalt = []
	vmChangeDefinition.each{|k,v|
		# add vms that were running and should be stopped now
		if vmStateBefore[k] == true and v == false
			vmsToHalt.push(k)
		end
	}

	# get list of vms to start
	vmsToStart = []
	vmChangeDefinition.each{|k,v|
		# add vms that were running and should be stopped now
		if vmStateBefore[k] == false and v == true
			vmsToStart.push(k)
		end
	}

	# handle stops
	vmsToHalt.each{|k|
		puts "stopping #{k} ..."
		if not stop_vagrant(k)
			puts "Failed to stop #{k}...exit"
			exit
		end
	}

	# handle starts
	vmsToStart.each{|k|
		puts "starting #{k} ..."
		if not start_vagrant(k)
			puts "Failed to start #{k}...exit"
			exit
		end
	}
# }}}
else
	puts "Wrong arguments ..."
	puts usage
	exit
end
