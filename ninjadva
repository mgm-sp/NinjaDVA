#!/usr/bin/env ruby

require "yaml"
require 'io/console'

# usage
usage = <<-END
    usage:
    #{$0} up -- start NinjaDVA components
    #{$0} halt -- stop components
    #{$0} status --- show running components
    #{$0} harthalt -- hart kill all VirtualBoxes system wide
END


# print usage if no no arguments
if ARGV.size == 0
    puts usage
	exit
end
# ---- define functions ------

def start_vagrant(pathToVagrantfile)
    return system("cd #{pathToVagrantfile}; vagrant up")
end

def stop_vagrant(pathToVagrantfile)
    return system("cd #{pathToVagrantfile}; vagrant halt")
end

def poweroff_all_virtualboxes()
    return system("vboxmanage list runningvms | sed -r 's/.*\\{(.*)\\}/\\1/' | xargs -L1 -I {} VBoxManage controlvm {} poweroff")
end

def get_running_vms()
    runningVmsRequest = `vboxmanage list runningvms`.split(/\n+/)
    runningVms = []
    runningVmsRequest.each{|e|
        runningVagrantVm = e.split("\"")[1].scan(/^(.*)_(.*)_[0-9]+_[0-9]+$/).flatten[0]
        # avoid adding vms not named in vagrant style
        if runningVagrantVm
            runningVms.push(runningVagrantVm)
        end
    }
    return runningVms
end

def get_last_subdirectory(longPath)
    # TODO: will this work under windows?!
    return longPath.split("/").last
end

def get_gateway_position(arrayOfVmPaths)
    return arrayOfVmPaths.index{|s| s=~ /gateway/}
end

# --- begin of script ------

# try to load config file
configFile = ".ninjadvarc.yaml"
vmSettingsConfig = {}
if File.exists?(configFile)
    vmSettingsConfig = YAML::load_file(configFile)
end

# search for subdirectories having Vagrantfile
vmsFound = Dir.glob("**/Vagrantfile").collect{|f| File.dirname(f)}

#handle no vms found
if vmsFound.length == 0
    puts "No VMs found :/ ... exit"
    exit
end

# handle no gateway vm found and exclude gateway from decision
gatewayPos = get_gateway_position(vmsFound)
if not gatewayPos
    puts "No gateway VM found :/ ... exit"
    exit
end
gatewayPath = vmsFound.delete(vmsFound[gatewayPos])


# merge vms found with vms in config
vmStartDefinition = {}
vmsFound.each{|e| vmStartDefinition[e] = false}
# get subset of vms that can be found currently
vmSettingsConfigExistSubset = vmSettingsConfig.select{|k,v| (vmStartDefinition.keys & vmSettingsConfig.keys).include?(k)}
vmStartDefinition.merge!(vmSettingsConfigExistSubset)
vmsCount = vmStartDefinition.keys.count
# get vm directories cleaned, only the last sub-directory
vmFoundCleaned = []
vmStartDefinition.keys.each{|e|
    vmFoundCleaned.push(get_last_subdirectory(e))
}


# ---- handle up ------
if ARGV.first == "up"

    puts "VMs with a [x] will be started:"

    loop do
        # print current vm config
        vmStartDefinition.each_with_index {|(k,v),i|
            start = v ? "X" : " "
            puts "[%s] %d  %s" % [start, i+1, k]
        }

        puts "Options: toggle VM start (1-%d), start chosen VMs (S), quit (q)" % [vmsCount]
        print "Decision [Sq1-%d]: " % [vmsCount]
        # get input
        decision = STDIN.gets.chomp

        puts "----------------------------"
        puts

        decisionAsNumber = decision.to_i
        if decision.downcase == "s" or decision == ""
            puts "....STARTING ..... *roedelroedel*....*klimper*...*piep*..."
            puts
            break
        elsif decision.downcase == "q"
            # quit script
            puts "...quit............................."
            exit
        elsif decisionAsNumber.between?(1,vmsCount)
            vmStartDefinition[vmStartDefinition.keys[decisionAsNumber-1]] = !vmStartDefinition[vmStartDefinition.keys[decisionAsNumber-1]]
        else
            puts "(!!!) WRONG INPUT [%s] :/" % [decision]
            puts
        end
    end

    # save new config
    File.open(configFile,"w") do |f|
        f.write(vmSettingsConfig.merge!(vmStartDefinition).to_yaml)
    end

    # start gateway
    puts "starting gateway ...."
    if not start_vagrant(gatewayPath)
        stop_vagrant(gatewayPath)
        puts "Failed to start gateway...exit"
        exit
    end

    # start other VMs
    vmStartDefinition.each{|k,v|
        if v
            puts "starting #{k} ...."
            if not start_vagrant(k)
                stop_vagrant(k)
                puts "Failed to start #{k}...exit"
                exit
            end
        end
    }
# ------- handle halt ------
elsif ARGV.first == "halt"
    # stop other VMs
    vmStartDefinition.each{|k,v|
        if v
            puts "stopping #{k} ..."
            if not stop_vagrant(k)
                puts "Failed to stop #{k}...exit"
                exit
            end
        end
    }
    puts "stop gateway..."
    # stop gateway
    if not stop_vagrant(gatewayPath)
        puts "Failed to stop gateway...exit"
        exit
    end

elsif ARGV.first == "harthalt"
    poweroff_all_virtualboxes()

elsif ARGV.first == "status"
    # get running vagrant vms matching subfolders we can find
    vmRunning = get_running_vms()
    vmRunningMatched = get_running_vms() & vmFoundCleaned

    gatewayPos = get_gateway_position(vmRunning)
    if not gatewayPos
        puts "Gateway is not running."
        puts "Run #{$0} up to start NinjaDVA."
        exit
    end

    # print current vm config
    puts "Running VMs are marked with [x]:"
    vmStartDefinition.each {|k,v|
        running = vmRunningMatched.include?(get_last_subdirectory(k))? "X" : " "
        puts "[%s] %s" % [running, k]
    }
else
    puts "Wrong arguments ..."
    puts usage
	exit
end
